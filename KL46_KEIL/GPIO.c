#include "GPIO.h"

#define SW1_PIN 3												/* SW1 switch is on port C - pin 3 */
#define SW3_PIN 12

#define button1 0												/* Button 1 is first in button_mask*/
#define button3 1												/* Button 3 is second in button_mask */

/*Number of IRQ generated by PORTC_PORTD interrupt*/
#define PORTC_D_IRQ_NBR 31 //(IRQn_Type) -1			/* ToDo 5.1: Define interrupt (IRQ) number for PORTC_PORTD. See interrupt vector assignments in NVIC section of KL46 Sub-Family Reference Manual - NVIC section*/ 


volatile uint8_t DataReady;   //interrupt flag
volatile uint8_t ButtonRe;   //interrupt flag
volatile uint32_t INT_PORTC;   //PTC5 int1   PTD1  int2

const static uint32_t button_mask[] = {1UL << 3, 1UL << 12};  //Button 1 is Port C bit 3, button 3 is Port C bit 12

void GPIO_init(void)
{
	SIM->SCGC5 |=  SIM_SCGC5_PORTC_MASK;
	
	PORTC->PCR[5] |= (0 | PORT_PCR_ISF_MASK |     // Clear the interrupt flag
                       PORT_PCR_MUX(0x1)|     // PTC5 is configured as GPIO
                       PORT_PCR_IRQC(0xA));   // PTC5 is configured for falling edge interrupts
	
		PORTD->PCR[1] |= (0 | PORT_PCR_ISF_MASK |     // Clear the interrupt flag
                       PORT_PCR_MUX(0x1)|     // PTD1 is configured as GPIO
                       PORT_PCR_IRQC(0xA));   // PTD1 is configured for falling edge interrupts
	
	NVIC_ClearPendingIRQ(PORTC_PORTD_IRQn);
	NVIC_EnableIRQ(PORTC_PORTD_IRQn);
	NVIC_SetPriority(PORTC_PORTD_IRQn, 4);
	
}

void buttonsInitialize(void){
	
	SIM->SCGC5 |=  SIM_SCGC5_PORTC_MASK; 					/* Enable clock for port C */
	PORTC->PCR[SW1_PIN] |= PORT_PCR_MUX(1);      
	
	PTC->PDDR &= ~button_mask[button1]; 
	
	PORTC->PCR[SW1_PIN] |=  PORT_PCR_PE_MASK |		
											PORT_PCR_PS_MASK;					


}


int32_t button1Read(void){
	return PTC->PDIR & button_mask[button1];						/* Get port data input register (PDIR) */
}



void PORTC_PORTD_IRQHandler (void)
{	
	DataReady = 1;
	PORTC -> PCR[5] |= PORT_PCR_ISF_MASK;
	
}


